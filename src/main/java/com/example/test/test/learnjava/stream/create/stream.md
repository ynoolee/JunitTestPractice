# 참조
참조라기에는 이글을 보고 그대로 실습하는 과정을 담고있다.
https://futurecreator.github.io/2018/08/26/java-8-streams/


# Streams
> JDK 8 Stream class 는 유용한 정적 유틸리티 메소드들을 갖고 있음.
> 
- Java 8 에서 추가한 스트림은 "람다"를 활용할 수 있는 기술 중 하나다. 
- JAva 8 이전에는 배열 or Collection 인스턴스를 다루는 방법은 for 문 또는 forEach 문을 돌면서 "요소를 하나씩 " 꺼내서 다루는 방법이었다. 
  - 로직이 복잡해질수록 코드양이 많아지고 복잡해지며 그 for 문 내부에서 로직이 섞이게 되었다.
  ```java
  for(int i =0; i<20;i++){ 
    Element e = List.get(i);
    if(e.over19()){
        if(e.alreadyWatched()){
            ......
        }
    }
  }
  ```
- 스트림은 "데이터의 흐름" 이다. 스트림에 람다 사용시, 코드의 양을 줄이고 간결한 표현이 가능하다. 즉 배열과 컬렉션을 함수형으로 처리할 수 있다. 
- 병렬처리를 간단하게 할 수가 있다. 여러 스레드를 사용하여 많은 요소들을 빠르게 처리할 수 있다. ( 핵심은, 이런 병렬처리를 "간단하게" 할 수가 있다는 것이다. )


## 스트림
1. 생성하기 : 스트림 인스턴스 생성
2. 가공하기 : 필터링 및 매핑 등 , 원하는 결과를 만들어가는 중간작업이다. 
3. 결과 만들기 : 최종적으로 결과를 만들어내는 작업 

## 생성하기 

### 배열 스트림
스트림을 생성하려면, 먼저 스트림 인스턴스를 생성해야 한다. 
- 배열 또는 컬렉션 인스턴스를 이용해 생성할 수 있다.

### 컬렉션 스트림
컬렉션 타입의 경우, 인터페이스에 추가된 디폴트 메소드 stream() 을 이용해서 스트림을 만들 수 있다. 
```java
public interface Collection<E> extends Iterable<E> {
  ...

  default Stream<E> stream() {
    return StreamSupport.stream(spliterator(), false);
  }
  ...
}
```
> 오 기존의 Collection 인터페이스에 스트림 인스턴스를 생성하는 기능을 추가하면서, 
> - 기존의 수많은 콜렉션 구현체들에도 backward compatibility 를 지원하기 위해 인터페이스에 디폴트 메소드를 추가하는 것을 볼 수 있는 예시라 생각함.

### 비어있는 스트림
- 비어있는 스트림은 왜 사용하는거지???
- 비어있는 스트림은 요소가 없는 경우 null 대신 사용할 수가 있다 ==> 즉, NPE 를 방지하는데 사용할 수 있다.

```java
    public static<T> Stream<T> empty() {
        return StreamSupport.stream(Spliterators.<T>emptySpliterator(), false);
    }

```

```java
	private Stream<String> streamOf(List<String> list) {
        return list == null || list.isEmpty()
        ? Stream.empty()
        : list.stream();
        }
```

```java
		List emptyList = null;

//		emptyList.stream().forEach(System.out::println); // NPE

		Stream emptyListStream = main.streamOf(emptyList);
		emptyListStream.forEach(System.out::println);
		
		emptyList = new ArrayList(); // 비어있는 리스트
        emptyList.stream().forEach(System.out::println); // 정상실행
```

### 스트림 빌더
- 빌더를 사용하면 스트림에 직접적으로 원하는 값을 넣을 수가 있다.
```java
		Stream<String> builderStream = Stream.<String>builder()
			.add("Eric").add("Elena").add("Java")
			.build();
```

### Stream.generate()
generate 메소드 사용시 Supplier<T> 에 해당하는 "람다" 로 값을 넣을 수 있다. 
- Supplier<T> 는 인자는 없고 리턴값만 있는 함수형 인터페이스로
- 람다에서 리턴하는 값이 들어간다

```java
    /**
     * Returns an infinite sequential unordered stream where each element is
     * generated by the provided {@code Supplier}.  This is suitable for
     * generating constant streams, streams of random elements, etc.
     *
     * @param <T> the type of stream elements
     * @param s the {@code Supplier} of generated elements
     * @return a new infinite sequential unordered {@code Stream}
     */
    public static<T> Stream<T> generate(Supplier<? extends T> s) {
        Objects.requireNonNull(s);
        return StreamSupport.stream(
                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);
    }
```
- 생성되는 스트림은 크기가 정해져있지 않고, 무한이기 때문에, 최대 크기를 제한해야한다. 

### Stream.iterate()
- "초기값" 과 "해당 값을 다루는 람다" 를 사용하여, 스트림에 들어갈 요소를 만든다. 
- 2의 pow 를 스트림으로 만들어보자
- 이 역시 스트림 사이즈가 무한이기에, 사이즈 제한 필요
```java
		Stream<Integer> iteratedStream = Stream.iterate(1, n -> n * 2).limit(30);
		iteratedStream.forEach(System.out::println);
```

## 기본 타입형 스트림
- 제네릭을 사용하면, Primitive type 에 대한 Wrapper type 스트림을 생성할 수 있다. 
- 하지만 제네릭을 사용하지 않고, 직접적으로 해당 타입의 스트림을 다룰 수도 있다. 
- 제네릭을 사용하지 않기에, 불필요한 오토박싱, 언박싱이 일어나지 않는다!!!
  - 필요한 경우, boxed 메소드를 사용해서 boxing 도 가능하다 
  - LongStream 과 Stream의 collect 메소드는 서로 다르다.

### 난수를 사용하여 Primitive stream 생성하기
Java 8 의 Random 클래스는 난수를 가지고, 세가지 타입의 스트림(IntStream, LongStream, DoubleStream) 을 만들어낼 수 있다. 
- 스트림인 난수를 생성해, 이들에 대한 후속 작업을 쉽게 취할 수 있다는 장점이있다.

### 문자열 스트링
- String 을 사용해 스트림 생성도 가능!!!
```java
	private void makeIntStreamUsingString(String str){
        IntStream valStream = str.chars();
        valStream.forEach(System.out::println);
    }
```


### 파일 스트림
자바 NIO 의 Files 클래스의 lines 메소드는 "해당 파일의 각 라인을 String 타입의 스트림" 으로 만들어준다.

### 병렬 스트림 Parallel Stream
- 스트림 생성 시 사용하는 stream() 대신 parallelStream() 메소드를 사용해 병렬 스트림을 쉽게 생성할 수도 있다. 
- 내부적으로는 스레드를 처리하기 위해 Java 7 부터 도입된 Fork/Join 프레임워크를 사용한다. 
- Collection -> 병렬 스트림 
- Array -> 병렬 스트림
- 컬렉션이나 배열이 아닌 스트림도 병렬스트림으로 만들 수있다. 
- 병렬스트림이어도 변수는 같아서, 해당 스트림이 병렬스트림인지 확인하려면
```java
boolean isParallel = stream.isParallel();
```
- 병렬스트림이 반드시 좋은 것은 아니기 때문에, 다시 sequential mode 로 돌아가게 할 수도 있다.

```java
intStream.sequential();
```


## 스트림 연결하기 
```Stream.concat``` 을 이용해 두 개의 스트림을 연결해 새로운 스트림 생성가능
- 2개 이상의 스트림을 연결하는 경우?? 
  - concat(..concat) --> 이런 구현이라면 개수가 늘어날 수록 복잡해지고, 심지어 intermediate 변수까지 생성한다.가독성 떨어지고
  - 오픈 소스 라이브러리 -> StreamEx : Java 8 Stream 의 기능을 확장시킨 자바 라이브러리. 
    - append 를 사용해서 가독성도 좋아지고
    - 인스턴스 메소드이기 때문에, 여러 스트림들을 쉽게 Chaining 또한 가능함. 