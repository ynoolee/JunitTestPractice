# 가공하기 

전체 요소들 중, api 를 사용하여 내가 원하는 것만을 뽑아낼 수 있다. 
- 가공 단계를 중간 작업(intermediate operations) 라고 한다. 
- 이 작업은 스트림을 리턴하기 때문에, 여러 작업을 chaining(이어붙여 작성) 할 수 있다.

## Filtering
filter 는 스트림 내 요소들을 하나씩 평가하여 걸러내는 작업.
- 인자로 Predicate 를 받는다. 
```java
Stream<T> filter(Predicate<? super T> predicate);
```

## Mapping ( 모던 자바 인 액션 책을 참고 함)
간단하게 : 스트림 내 요소들을 "하나씩 특정값으로 변환" 해 준다. 
- 이 때, 값을 변환하기 위한 로직이 필요하기에, 람다를 인자로 받는다. 
```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper);
```
- 인자로 제공된 함수는 "각 요소" 에 적용 -> 함수를 적용한 결과가 새로운 요소로 매핑 된다. => 리턴되는 새로운 스트림에 담기게 된다. 

예시) 메뉴의 각 요리 이름 리스트를 뽑아내기 
```java
menu.stream()
        .map(Dish::getName)
        .collect(toList());
```

예시) 메뉴의 각 요리명의 길이 리스트를 뽑아내기
```java
menu.stream()
        .map(Dish::getName)
        .map(String::length)
        .collect(toList());
```


### flatMap
스트림의 평면화

예시) 메뉴의 각 요리명 리스트를 뽑아낸 것에서, 고유 문자로 이루어진 리스트를 뽑아내 보자. 
(["abc","cddd"]) 리스트가 뽑아졌었다면, ["a","b","c","d"] 를 포함하는 리스트가 반환되어야 한다. 
- 단순하게 생각하면 : 리스트의 각 단어를 문자로 매핑 -> distinct 로 중복된 문자를 필터링 
```java
words.stream()                              // Stream<String>
        .map(word -> word.split(""))
        .distinct()
        .collect(toList())
```

를 생각할 수도 있는데 "문제점" 이 있음 -> ```.map(word -> word.split(""))``` 는 String[] 을 반환. 
- 즉, ```Stream<String[]>``` 형식이 되어버린다
  - 현재 내가 원하는 형식은 ```Stream<String>``` 이다. 
  - distinct 를 하기 전에, Stream<String> 이 되어야 한다. 
  - 배열 스트림(```Stream<String[]>```) --> 문자열 스트림(```Stream<String>```) 으로 만들 방법이 필요 
  

Arrays.stream() 를 사용한다면????
```java
		// Stream<String[]> --> Stream<String>
		List<String> words = List.of("abc","cddd"); // ImmutableCollection 생성 
		// 시도 1 
		List<Stream<String>> listOfStream = words.stream() //
			.map(str -> str.split("")) // 각 단어 -> String[] 
			.map(strings -> Arrays.stream(strings))// 각 String[] --> Stream<String>
			.distinct()
			.collect(toList()); // List<Stream<String>>
```
해결되지 않음. 
- 현재 필요한 것 : ```Stream<String[]> ``` ({"a","b","c"} 랑 {"c","d","d","d"})--> ```Stream<String>```({"a","b","c","c","d","d","d"}) 으로 만드는게 필요 

여기에 사용될 수 있는 것이 flatMap 이다.

```java
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
```

기존에는 map(Arrays::stream) --> Stream<String[]>

flatMap(Arrays::stream) ---> Stream<String>
> 즉, flatMap 은 평면화된 스트림을 반환.
> - " 스트림의 각 값(String[])" 을 -> "다른 스트림" 으로 만든 다음 -> "모든 스트림을 하나의 스트림으로 연결" 



- 인자로 매퍼를 받는 것은 map과 같으나, "리턴타입이 스트림" 이다. 
  - 즉, 새로운 스트림을 생성해서 리턴하는 람다를 넘겨야 한다.
  - 중첩 구조를 한 단계 제거하고, 단일 컬렉션으로 만들어주는 역할을 한다 => flattening 을 해준다. 

### map 과 flatMap 의 차이 
보통 인수로 받은 함수를 스트림의 각 요소에 적용하면 -> 스트림의 스트림이 만들어진다.

하지만 flatMap 은 인수로 받은 함수를 적용해서 생성된 각각의 스트림에서, 콘텐츠만 남긴다. 
- 즉, 함수를 적용해 생성된 모든 스트림이 하나의 스트림으로 병합되어 플래트닝 된다.
  - 2차원의 List --> 1차원 List 로 평준화 하는 것이 가능하다. 

> Optional 에서 map, flatMap 

```java
    IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper);

```



## Sorting
- 다른 것과 마찬가지로 Comparator 를 이용한다 
  - 어떤 인자도 전달하지 않으면 기본은 오름차순이다.

## Iterating
스트림 내 요소들 각각을 대상으로 특정 연산을 수행하는 메소드로 peek 이 있다. 
peek 은 "그냥 확인해 본다" 는 단어 뜻 처럼, "특졍 결과를 반환하지 않고 consume만 하는 함수형인터페이스"인 Consumer 를 인자로 받는다.
- 스트림 내 요소들 각각에 특정 작업을 수행할 뿐, 
- 결과에 영향을 미치지 않는다. 
- 작업 처리 중간에 결과를 확인해 볼 때 사용할 수 있다. 