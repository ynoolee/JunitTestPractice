# 결과만들기
가공한 스트림을 갖고 , 내가 사용할 결과값으로 만들어내는 단계.
- 스트림을 끝내는 최종단계 

## Calculating
- 스트림 API 는 "다양한 종료작업" 을 제공한다.
  - 최소
  - 최대
  - 합
  - average
  등 primitive type 으로 결과를 만들어 낼 수 있다. 
```java
long count = IntStream.of(1,3,5,7,9).count();
long sum = LongStream.of(1,3,5,7,9).sum();
```
- 만약, 스트림이 비어있는 경우
  - count, sum --> 0 리턴
  - 평균,최대,최소 -> Optional 

## Reduction
> 사용자가 원하는대로 결과를 만들어내기 위한 메소드로 --> reduce(), collect() 를 제공

> Stream 의 데이터는 변환하지 않고, 더하거나 빼는 등의 연산을 수행해 하나의 값으로 만들 수 가 있다. 

- Stream 은 reduce 라는 메소드를 사용해 결과를 만들어낸다. Stream 에 있는 여러 요소의 총합을 낼 수도 있다. 

총 세 가지 파라미터 받을 수 있음
- accumulator : 각 요소를 처리하는 계산로직. 각 요소가 올 때 마다 중간 결과를 생성하는 로직
- identity: 계산을 위한 초기값으로, 스트림이 비어 계산할 내용이 없더라도 이 값은 리턴
- combiner : 병렬 스트림에서 나눠 계산한 결과를 하나로 합치는 동작을 하는 로직

받을 수 있는 인자에 따른 오버로딩이되어있음
```java
// 1개 (accumulator)
Optional<T> reduce(BinaryOperator<T> accumulator);

// 2개 (identity)
T reduce(T identity, BinaryOperator<T> accumulator);

// 3개 (combiner)
<U> U reduce(U identity,
  BiFunction<U, ? super T, U> accumulator,
  BinaryOperator<U> combiner);
```

- BinaryOperator<T> accumulator --> 같은 타입의 인자를 두 개 받아, 이와 같은 타입의 결과를 반환하는 함수형 인터페이스
  - 궁금한것 -> BinaryOperator 에 전달되는 인자가 하나 밖에 없는 경우 
- Combiner : 병렬 처리 시 각자 스레드에서 실행한 결과를 마지막에 합치는 단계이기에 병렬 스트림에서만 동작한다
- 병렬스트림은 순차적으로 연산을 수행하지 않고 여러개의 작업을 병렬로 처리한다. 
- Combiner 는 Identity 와 accumulator 를 갖고 여러 스레드에 나눠 계산한 결과를 합치는 역할.
- 병렬 스트림이 무조건 시퀀셜보다 좋은 것은 아니다. 오히려 간단한 경우에는, 이렇게 부가적인 처리(identity 와 acuumulator를 갖고 여러 스레드에서 나눠 계산하고 -> 마지막에 그 결과를 합치기)
  가 필요하기 때문에 오히려 느릴 수 있다. 
> ???? 사실 이거 예시 이해가 안됨....


# Collecting
> collect 
- Collector 타입의 인자를 받아 처리: Collectors class 에서 다양한 메소드를 제공 해 주고 있음
```java
    <R, A> R collect(Collector<? super T, A, R> collector);
```
- Collectors.toList() -> 스트림에서 작업한 결과를 담은 리스트로 반환
- Collectors.joining() -> 스트림에서 작업한 결과를 하나의 스트링으로 이어붙인다 
  - delimiter : 각 요소 중간에 들어가 요소를 구분시켜주는 구분자
  - prefix : 결과 맨앞에 붙는 문자
  - suffix : 결과 맨 뒤에 붙는 문자 
- Collectors.averageingInt() : 숫자값의 평균을 낸다 => Primitive type 별로 제공
- Collectors.summingInt() : 숫자값의 합을 낸다. => Primitive type 별로 제공
  - mapToInt() 을 통해 IntStream 으로 변환한 후 IntStrem 의 sum() 을 할 수도 있다
- Collectors.summarizingInt() : 만약 "합계" 와 "평균" 모두 필요하다면? -> 스트림을 두 번 생성해야할까???
  - 이 정보들을 한 번에 얻기 위해 summarizingInt 메소드 사용가능 => Primitive type 별로 제공
  - 리턴 타입 : IntSummaryStatistics 에 들어있는 정보
    - 개수 
    - 합계
    - 평균
    - 최소
    - 최대
- Collectors.groupingBy() : 특정 조건으로 요소들을 그룹짓기.
  - 인자 : 함수형 인터페이서 Function 
- Collectors.partitioningBy() : groupingBy는 함수형 인터페이스 Function 을 이용해, 특정 값을 기준으로 스트림 내 요소들을 묶었다면
  - partitionBy 는 함수형 인터페이스 Predicate 을 받는다. Predicate 는 인자를 받아 boolean 값을 리턴한다.
  - Predicate 에 따라, 스트림 내 요소들을 tur, false 두 가지로 나눌 수 있다. 
  - Collectors.collectingAndThen() : 특정 타입으로 결과를 collect 한 뒤, 추가 작업이 필요한 경우 사용 가능. 
    - finisher 는 collect 를 한 후에 실행하는 작업

여러 상황에서 사용할 수 있는 메소드들을 살펴보았다. 이 외 필요한 로직들은 직접 collector를 만들 수도 있다. 
- Collector.of()
  - accumulator, combiner 는 reduce 에서 봤던 것과 동일하다.
  - 

# Matching
- 조건식 람다 Predicate 를 받아, 해당 조건을 만족하는 요소가 있는지 체크한 결과를 리턴한다. 
- 다음 세가지 메소드
  - 하나라도 조건을 만족하는 요소가 있는지 -> anyMatch
  - 모두 조건을 만족하는지 -> allMatch
  - 모두 조건을 만족하지 않는지 -> noneMatch

# iterating
- forEach 는 요소를 돌면서 실행되는 최종작업. 
- "스트림가공" 에서 다루었던 peek 와는 "중간작업인지 or 최종작업인지" 의 차이가 있다. 
