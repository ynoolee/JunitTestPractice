

# OOP 이야기

## 1. 객체지향 프로그래밍

- JVAA : 등장부터 나는 "객체지향언어다!!" 라고 하며 나옴
- JAVA 언어 사용한다고 객체지향 프로그래밍하고 있는 건 아님
- 객체지향 철학에 맞게 프로그래밍을 해야 OOP 를 하는것
- OOP 란 ? 프로그램을 "객체"로 구성하는 것
- 왜 등장했나?? ==> 프로그램이 거대해지면서 등장하였다.
  - 다른 사람이 와서 이를 유지보수하거나 관리하는데서 문제가 생김
  - 큰 프로그램을 어떻게 만드는게 더 효율적인가??에 대한 고민
  - 해결책 : 작게 나눠서 만들고 합치자
- 프로그램의 "동작"을 "객체" 들에게 나눠서 수행 
  - 기능의 요소를 잘게 쪼개서 객체들에게 분산하자 
- 객체 : "개념적인" 용어 / 기술적 용어 : class, instance 임. ( 객체지향의 사실과 오해라는 책을 보면 또 나와있음)
- 객체는 작은 기능을 수행한다.
- 객체와 객체는 서로 협력.
===> OOP에서 원하는 것: 일을 잘게 쪼개서 객체에게 위임하고, 서로 협력하게 만드는 것 
- 객체에게 책임을 주고 , 그 책임을 다하도록 하는 것. 일을 잘게 쪼개고 객체들이 서로 잘 협력할 수 있도록 하는 것. 
- 객체를 서로 구분할 필요가 있다. 객체는 어떤 책임을
  - type(형) 으로 구분한다.
  - ```String str = "Hello World"```
- 타입 만들기 : class 만들기

```java
package com.programmers;

import java.lang.*;

class MyObject extends Object implements Runnable{
    // 필드 영역
    private int a = 0;
    // 메소드 영역
    public void run() {
        a += 1; 
    }
}
MyObject obj = new MyObject();
```

## 2. 객체지향의 특성

### (1) 캡슐화

1. 완성도가 있다. 
- 기능을 수행하는 단위로서 완전함을 갖는다.
2. 정보가 은닉되어 있다. 
- 객체의 정보가 밖으로 전달되거나, 밖에서 객체 내의 정보에 접근하지 못하게 한다.

=> 객체는 스스로 동작할 수 있는 환경을 갖고 있어야 한다.
외부에 의존하거나, 외부의 침략을 제한하여야 한다. 

```java
class Human{
    Heart h;
    Blood b;
}

Human h = new Human();
h.heart.stop(); // Human 의 중요한 부분을 외부에 의해서 침략당하는 것 
```
외부에서 접근을 할 수 없도록 하자 
```java
class Human{
    private Heart h;
    private Blood b;
    protected Gene gene;
    // 접근을 허용하기는 하되, 이를 Human 객체에서 관리하도록 한다
    void donation() {
        return null; // 내부적으로 컨트롤하다보니, 이런식으로 제어하는 것도 가능하다.( 주고 싶지 않은 경우 이런식으로 주지 않는 것으로 할 수도 있다 )
    }
}

Human h = new Human();
h.donation(); // 외부에서 직접 human 의 피를 가져가는게 아님 
```
- 접근 지정자를 통해 "캡슐화" 를 조절한다.
    - private : 객체 소유
    - protected : 상속된 객체에서도 접근 가능.( 상속 관계인 경우만 가능
    - friendly : 같은 "패키지 내" 에서 접근 가능 ( 패키지 가시성 )
      - 대체 언제 쓰일까??  변수 선언 , 객체 자체를 선언할 때
      ```
      com.programmers
      com.programmers.girl
                            Secret
      com.programmers.body
                            Secret
      
      ```
      girl 안의 패키지 내부에서 여자들끼리만 공유하는 비밀이 있고, 남자들끼리만 공유하는 비밀이 있다고 하자
      - 외부에서는 이 패키지 내부에 접근하지 못한다. 
      - 패키지 가시성.
      - 패키지 내에서만 어떤 객체에 대한 접근을제한하고 싶을 때.
    - public : 한 파일에 하나만 있어야함. 해당 파일은 이 public 객체의 이름과 같아야 한다. 

```java
class Child extends Human {
    void run() {
        this.gene; // protected 에는 접근 가능
        
        // super.heart (x) 접근 불가능
        // this.heart (x) 접근 불가능
    }
    
}
```


### (2) 상속 

- 상위, 부모, super, 추상적이다
- 하위, 자식, this, 구체적이다

- 오해 : 공통된 기능을 여러 객체에게 전달하고 싶을 때. (기능으로 접근하는..오해)

그게 아니라, 상속관계는 "추상"적인것과 "구체"적인 것의 관계 로 보아야함 (부모와 자식 관계는, 추상적인 것과 구체적인 것의 관계)
- (일반,추상화) 동물 > 포유류 > 사람 > 남자 > 짱구  (구체)
- 남자 > 남자어린이 > 짱구 도 되나요? -> "어린이" 라는 것은 기준이 명확하지 않기에 프로그래밍에서는 적절하지 않다는 의견


### (3) 추상화
위로 올라갈수록 추상화된 형태, 아래로 갈 수록 구체화된 형태 를 "상속" 이라 했엇음

- 추상화된 객체 : 추상체
- 구체적인 객체 : 구상체
- 추상체와 구상체의 관계는 "서로 상대적" 인 것. 
- 객체간의 관계에서 상위에 있는 것이 항상 하위보다 추상적이어야 한다. 

```java
// 의미적 추상체
// 둘은 서로 독립적인데, 의미적으로 보면 Login 이 좀 더 추상적인 개념임
class Login {
    void login();
}
class KakaoLogin extends Login {
    void login();
}
```
java 언어에서는, 일부를 추상으로 만들 수도 있다. 
추상 기능을 가진 객체를 만들어 보자
```java
// 추상 기능을 가진 객체
class Login {
    void login();
}
// 반드시 오버라이드 해야하는 메소드가 있음 
class KakaoLogin extends Login {
    void login() {}
}

```

객체 자체가 추상적
```java
// 모든 것이 다 추상으로만 이루어져있는 객체 

interface Login {
    void login();
}
class KakaoLogin implements  Login {
    @Override void login() {}
}
```
- JAva 에서는 추상체를 만드는 방법으로 인터페이스, 추상클래스 , 의미적으로 연관관계를 갖도록 하는방법 

- 왜 추상체를 가져야할까??

### (4) 다형성
- 형 (type) 을 여러가지로 표현할 수 있다. (Login 이라는 형을 , 여러가지 구현체(KakaoLogin) 으로 표현할 수 있다)

```java
class KakaoLogin implements  Login {
  @Override void login() {}
}
Login login = new KakaoLogin();
login.login();
```
- 이렇게 하면 뭐가 좋은가?? 
  - 구체클래스는 다르지만 **하나의 추상클래스로 표현**할 수 있다. 
  - 이 타입이 가지고 있는 기능은 login() 이라는 것은 알 수 있다. 

프로그램은 객체들의 구성이라 하였음. 
- user가 접근할 때는 쇼핑몰, 판매자입장에선 판매처, 운영자입장, 엔지니어 입장.. 같은 시스템이지만 접근하는 사람에 따라 접근하는 관점이 달라짐.
    시스템 내에 어떤 기능이 있어도, 접근하는 사람에 따라 그 기능을 제공하지 않아도 된다.
- 같은 객체지만, 누가 접근(아래 코드에서 Login 타입 객체, Portal 타입 객체 )하냐에 따라 필터링된 기능만 제공 해 준다.
  - 캡슐화가 되기 위해서, 객체가 독립적으로 존재하고, 자기의 일을 수행하기 위해선, 남한테서 빼오거나 , 남의것에 접근해서는 안 된다.
  - 객체 사이 협력관계에서는, 해당 객체가 요청할 수 있는 권한의 것만 요청할 수 있는 것. 

```java
interface Portal {
    public void portal();
}

public class NaverLogin implements Login, Portal{
    public void naver();
    @Override public void login(){}
    @Override public void portal(){}
}

Login login = new Login();
Login login = new KakaoLogin();
Login login = new NaverLogin();
login.login();

Portal portal = new NaverLogin();
portal.portal();

```
![](../../../../../../../../../../../../Downloads/IMG_001B7D88AD69-1.jpeg)
- 나머지는 private 으로 캡슐화하여 , B,C 객체에서 직접적으로 호출이 불가능하도록 한다. 
  - 객체간의 협력관계에서 자유롭게 사용되지만 "안전하게 사용될 수 있도록" 하는 것.
  - 객체가 업무를 분할해서한다. 협력해서 일한다. 일르 잘 하기 위해 안정성을 확보하다보니 캡슐 화필요,상속,추상화, 다형성이 필요했던 것.

## 3. 객체지향 설계 : 어떻게 하면 객체 지향을 잘 할 수 있는 것인가??
- 객체 지향 프로그래밍 : 기능을 객체에게 나눠서 수행시킨다. 
  - ==> 객체를 어떻게 구성했다. == 일을 어떻게 분할했다.
  - ==> 객체간의 관계가 어떻게 구성되었다. == 객체간의 연관관계가 어떠하다.


내가 만든 프로그램을 다른 사람에게 설명하기 위한 도구 
- 어떻게 객체가 나누어져있는지. 그 관계가 어떻게 되어있는지(이용관계가 어떠한지 같은..) 설명할 수 있어야 ==> UML
  - 유즈케이스 다이어그램
  - 시퀀스 다이어그램
  - 패키지 다이어그램
  - 클래스 다이어그램
- Tool : draw.io , starUML, 
  - 클래스를 "사각형" 으로 쓰고, 이름을 쓴다. 

다음과 같은 것들을 표현할 수 있어야 한다. 
- 어떤 클래스들로 내 시스템을 구성했느냐 
  - 그 구성된 객체들이 서로 어떤 관계를 갖고 있느냐


### (2) 어떻게 하면 객체를 잘 나누고 연관지을 수 있느냐???

어떻게 나누고, 어떻게 연관관계를 맺는 것이 좋은걸까????
- 객체지향 설계를 하는 5가지 원칙
- (1) S :SRP 단일책임원칙 ( 객체는 하나의 책임만을 진다. 그 객체가 지는 의무, 기능은 하나만 있어야 한다. -->이 객체 수정할 일은 " 그 책임" 으로 인해서만 이어야 한다.)
- (2) O : OCP : 수정에는 닫히고, 확장에는 열린다. (객체가 수정되어야 하는 경우, 그 객체를 수정하지 않고, 확장을 하는 방식으로 기능을 수정할 수 있어야 한다.)
- (3) L : LSP : 추상객체로 사용되는 부분에 구상객체가 들어가도 아무 문제 없어야 한다. (객체간의 관계를, 추상 - 구상으로 맺었다면, 이는 자연스럽게 맺어진다. 객체사이의 관계가 "추상-구상"으로 명확하다면 이는 자연스레 지켜질 것. 반면, "공통기능" 을 초점으로 "상속관계" 를 맺었다면 그렇지 않을 확률이 높음.)
- (4) I : ISP : 인터페이스 분리 원칙 : 이미 위에서 했음, 두개의 기능을 위해 Login, Portal 인터페이스로 나누었었음. 
- (5) D : DIP 

이 원칙을 어떻게 "응용" 하는가????
- 원칙에 따라 설계를 해봄 ==> 여러가지 경우에서 공통점이 보인 것. 
- 공통점들을 모아 책으로 출판함 => 디자인패턴
- 23 가지 디자인패턴
- 이 패턴을 이해하고 있다면, 위의 다섯가지 원칙을 잘 적용하고 있는 것일 거임. 


- SOLID 원칙을 이해하려고 하는 것 보다, 디자인패턴들을 통해 SOLID 원칙 이해하는 것이 더 좋은 방법


